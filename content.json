[{"title":"DDD基本概念的理解","date":"2020-07-06T14:43:51.000Z","path":"2020/07/06/DDD基本概念/","text":"DDD基本概念上下文1表示一个领域模型的范围，确定这个领域的边界。 对象值1对象值最主要的特点是，它的没有状态的，或者说它在当前上下文中的状态是不会变的。 实体 1实体最大的特点是，它是有状态的，而且在当前上下的情况它的状态是会改变的。实体还可能是有关联关系的，那个时候最顶层的实体就是根实体。 聚合1聚合是一个整合了实体和对象值的一个树状的数据对象。 领域事件1领域内的实体发生了状态转变的行为，就是一个领域事件。 领域服务1领域内那些实体状态不发生变化的行为可以就是领域服务。 六边形架构1六边形架构是一个比较自由的架构方式，没有特别严格的约束。 模块1根据代码功能划分的小集合，划分方式没有强制的要求，主要是根据程序的架构，上下等，把用于程序划分为功能内聚的模块。 资源库1简单的理解资源库就是储存领域内实体和值对象的方式，数据库持久化只是资源库保存数据的一种方式。 应用程序1应用程序是在六变形构架内部，包含一整块完整领域功能的代码集。应用程序会包含一个或多个上下文。","tags":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://a337928.github.io/tags/DesignPatterns/"},{"name":"DDD","slug":"DDD","permalink":"http://a337928.github.io/tags/DDD/"}]},{"title":"spring事务传播机制的实践","date":"2020-06-01T14:37:39.000Z","path":"2020/06/01/spring事务传播机制的实践/","text":"spring事务传播机制的实践先复习下传播机制类型PROPAGATION_REQUIRED (默认) 支持当前事务，如果当前没有事务，则新建事务 如果当前存在事务，则加入当前事务，合并成一个事务 REQUIRES_NEW 新建事务，如果当前存在事务，则把当前事务挂起 这个方法会独立提交事务，不受调用者的事务影响，父级异常，它也是正常提交 NESTED 如果当前存在事务，它将会成为父级事务的一个子事务，方法结束后并没有提交，只有等父事务结束才提交 如果当前没有事务，则新建事务 如果它异常，父级可以捕获它的异常而不进行回滚，正常提交 但如果父级异常，它必然回滚，这就是和 REQUIRES_NEW 的区别 SUPPORTS 如果当前存在事务，则加入事务 如果当前不存在事务，则以非事务方式运行，这个和不写没区别 NOT_SUPPORTED 以非事务方式运行 如果当前存在事务，则把当前事务挂起 MANDATORY 如果当前存在事务，则运行在当前事务中 如果当前无事务，则抛出异常，也即父级方法必须有事务 NEVER 以非事务方式运行，如果当前存在事务，则抛出异常，即父级方法必须无事务 实践问题1 在有两个在事务A和B的情况下，如果B事务嵌套在A事务里面，在默认的传播机制下，子事务如果抛出异常，会使主事物也一起回滚，导致整个事物都回滚，这个就是合并成一个事务的意思。 如果使用NESTED级别的传播机制，子事务抛出异常，但是主事务可以正常提交的情况下，主事务可以里面的内容可以正常保存，子事务会回滚。spring通过一个safePrint（安全点）机制去实现了这个功能，大概的意思是spring事务的执行在进入子事务时会写入一个safePrint如果出现异常的话，只回滚到这个safePrint。 同样的问题如果使用REQUIRES_NEW级别的传播机制，也可以保证主事务可以正常提交的情况下，主事务可以里面的内容可以正常保存，子事务会回滚。两者的区别是REQUIRES_NEW是分成两个事务分别提交的，而NESTED是主事务提交的时候一起提交的。其实REQUIRES_NEW可以堪称看成是两个不同的事务。 实践问题2 在一个事务里面如果要使用到乐观锁，但是这个锁锁定的是调用外部接口的能力，那就必须在这个乐观锁上单独加上NOT_SUPPORTED，这样才可以在使得在调用外部接口前就已经获得了锁定。","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://a337928.github.io/tags/spring/"},{"name":"mysql","slug":"mysql","permalink":"http://a337928.github.io/tags/mysql/"}]},{"title":"DefaultSingletonBeanRegistry类各map作用解析","date":"2017-12-25T14:40:42.000Z","path":"2017/12/25/DefaultSingletonBeanRegistry类解析/","text":"spring类创建过程中各map的作用在spring创建过程中有好多容器map，看的时候有点绕在这里独立开个类来记录下/** * 单例对象缓存，key：beanName value：instance */ private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256); /** * 单例工厂缓存，key：beanName value：ObjectFactory */ private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16); /** * 早曝光单例对象缓存（用来解决循环依赖），key：beanName value：instance */ private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16); /** * 已经注册的单例集合，包括注册队列里bean的name */ private final Set&lt;String&gt; registeredSingletons = new LinkedHashSet&lt;&gt;(256); /** * 目前正在创建的bean的name列表 */ private final Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16)); /** * 目前正在从创建检查中移除的bean的name列表 */ private final Set&lt;String&gt; inCreationCheckExclusions = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16)); /** * suppressed exception列表 */ @Nullable private Set&lt;Exception&gt; suppressedExceptions; /** * 所有单例当前是否正在被销毁 */ private boolean singletonsCurrentlyInDestruction = false; /** * 一次性使用的单例对象缓存，key：beanName value：instance */ private final Map&lt;String, Object&gt; disposableBeans = new LinkedHashMap&lt;&gt;(); /** * 存放bean之间包含关系 containingBean-&gt;containedBean[] 包含注册表 */ private final Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap = new ConcurrentHashMap&lt;&gt;(16); /** * 存放bean的依赖关系 bean(key)依赖那些bean(value) 依赖注册表 */ private final Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = new ConcurrentHashMap&lt;&gt;(64); /** * 存放bean的依赖关系 key被那些value依赖 这样两个Map的为了加快查询速度,牺牲空间 被依赖注册表 */ private final Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = new ConcurrentHashMap&lt;&gt;(64);","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://a337928.github.io/tags/spring/"}]},{"title":"spring－容器工厂实例化流程（spring 5源码master分支）","date":"2017-12-23T15:30:18.000Z","path":"2017/12/23/spring－容器工厂实例化流程（spring-5源码master分支）/","text":"1.Sourcespring 初始化最先获得资源如url，url,file的source对象 2.BeanDefinitionReader然后通过各个对应的BeanDefinitionReader阅读器解析出资源对象的document对象3.beanDefinition1.通过解析document对象去注册BeanDefinition,其中根节点的对象是RootBeanDefinition。 2.document对象是一个xml的对象，每解析成功一个熟悉就保持到DeanDefinition对象中去，直到整个document解析完毕。 4。AbstractBeanFactory从这里才真正开始spring获取和新建bean。 3.getBean方法，是获取bean的开始，真正开始获取bean的操作是从doGetBean开始的 4.先通过name获得BeanName，因为工厂bean的名字前面需要加“&amp;“符号 5.然后检查singleton是否有bean实例已经生成，spring先不管你的bean是单列模式还是原型模式，一上来就先去单利的注册器中去获取缓存中已经实现的bean 1).先从singletonObjects中查找是否有已经实例化的bean有则返回 2).没有在加载完成的bean则去看是否正在加载中，如果都没有则直接返回null； 3).如果是正在加载中，则看是否已经提前曝光 4).如果没有提前曝光，则判定是否可以提前曝光，如果不可用则直接返回null； 5).如果可以提前曝光则去获取当前beanName的已经加载完成的工厂bean缓存中的实例 6).如果factory存在存在这个实例，则提前曝光当前bean，然后移除这个工厂。 6.如果检查有实例返回，则去getObjectForBeanInstance这个方法中去获得自己正在需要的bean 1).则检查当前的beanname如果是工厂bean的名字，但是已经获取的beanInstance不是工厂bean则直接返回异常 2).如果是普通bean实例则直接返回beanInstance对象就可用 3).如果是factoryBean, 则去查找当前beanName的RootBeanDefinition并且合并所有parentBeanDefinition的属性，获取synthetic属性后去创建实例 4).生成factoyBean使用getObjectFromFactoryBean这个方法 5).如果创建的是单列，而且缓存中已经有这个bean * 则从缓存factoryBeanObjectCache获取当前实例，如果缓存中有bean则直接返回 * 如果没有则用doGetObjectFromFactoryBean生成 这个方法主要做来两件是， + 第一件是如果这个bean的安全管理System.getSecurityManager不是null的话就用AccessController.doPrivileged方法 去实现factory.getObject()方法，否则的话就是直接factory.getObject()方方法取得 + 第二件是如果获取的object是null的话判定这个bean是否是正在创建的如果是则抛出异常，不是的话则返回一个NullBean * 返回过来的object后，再去factoryBeanObjectCache取一次缓存实例，alreadyThere + 如果alreadyThere有缓存则覆盖前面拿到的bean，因为循环依赖前面给的bean有可能是nullbean + 否则的话，如果shouldPostProcess 是ture 需要去调用postProcessObjectFromFactoryBean 这个后置处理，然后放入factoryBeanObjectCache + 这里返回的object就是这次 getbean正在得到的bean 7.如果没有实例返 1).如果是在一个原型模式的循环引用中又引用到了自己，则抛出异常 2).检查是否有parentBeanFactory，如果有而且也包含beanName的BeanDefinition 如果parentBeanFactory实现了AbstractBeanFactory，则直接调用parentBeanFactory中的doGetBean获得bean 否则的话调用parentBeanFactory的getBean来获得bean 3).如果没有parentBeanFactory,则开始加载 4).如果typeCheckOnly是false则调用markBeanAsCreated标记这个beanname到正在创建的map缓存中alreadyCreated 5).然后开始用getMergedLocalBeanDefinition合并bean的BeanDefinition到RootBeanDefinition中 6).用checkMergedBeanDefinition检测合并后的得到的RootBeanDefinition 7.)通过RootBeanDefinition.getDependsOn()获取这个bean所依赖的beanName数组，如果者beanname不为空则通过递归先去实例化这些bean 8).如果前面的都bean都实例化完成来，则通过检测RootBeanDefinition的scope类型来分别实例化各个bean 9).先从singleton模式开始 * 第一步先用getSingleton来创建bean，用了函数式方法传入createBean(beanName, mbd, args); * getSingleton第一步先锁定singletonObjects后再去获取缓存中是否有对应的bean缓存，有缓存则直接返回实例 * 如果为空则去检测是否可用实现单列，不行直接返回异常 * 调用创建单利的前置方法beforeSingletonCreation，默认实现就是一个简单的注册beanname * 通过传入的createBean方法返回的factoryBean的getObject去获取实例object * 调用创建单利的后置方法afterSingletonCreation，默认就是从正在创建的map中移除当前bean * 然后调用addSingleton去实现bean 的注册，加入到singletonObjects缓存，并注册到registeredSingletons， 从早曝光缓存earlySingletonObjects和singletonFactories中删除， * 返回实例以后调用getObjectForBeanInstance，和前面直接从缓存中获取bean后调用的方法相同 10).如果是prototype模式 * 先通过beforePrototypeCreation注册原型正在创建的缓存中 * 通过createName创建bean * 后置处理afterPrototypeCreation方法从原型创建缓存中删除创建完成的bean * 返回实例以后调用getObjectForBeanInstance，和前面直接从缓存中获取bean后调用的方法相同 11).其他的模式 几乎和原型模式创建的方法类似。5.AbstractAutowireCapableBeanFactory上面在doGetBean中有一个很重要的方法createBean方法是没有实现的，这个方法是在AbstractAutowireCapableBeanFactory这个类中实现的。 1.createBean这个方法是spring创建bean的方式 2.开始创建bean时先要确定bean的类型，使用resolveBeanClass方法。 1).先从RootBeanDefinition.hasBeanClass() 中获取已经加载好的类型，如果有已经确定好的类型，就直接返回 2).如果没取到则需要直接去解析，使用doResolveBeanClass()方法。这里又看到System.getSecurityManager这个安全检测，用途和factory.getObject一样。 3).真正解析在这里doResolveBeanClass()里面有一头大象 * 让我们来解析这头大象，首先确定classload类加载器， * 然后检测typesToMatch，前面给入的类型参数，这里typesToMatch，这个参数一定是null，因为前面没传入。 + 如果typesToMatch不等于空则获取一个临时类加载器getTempClassLoader() + 如果有临时的类加载器，并且是继承于DecoratingClassLoader类加载器的就用这个的excludeClass方法去排除装饰器来确定使用那个构造方法。 + 然后通过RootBeanDefinition取出className + 调用 beanExpressionResolverevaluate方法，去评估下给定的beanName是否使用spEL表达式，如果是就用解析其解析后对象 + 如果从mdb中取出的className和解析出来的evaluated对象不相同的话就表示这里使用来动态解析表达式 + 如果evaluated是class是直接返回对象，如果evaluated是String就通过反射生成对象返回，其他情况都抛出异常 + 相反如果从mdb中取出的className和解析出来的evaluated对象相同的话就去反射className生成对象返回。 * 获得解析结构对象后如果mdb是类的话就把它升级为一个RootBeanDefinition，然后把解析生成的对象给到这个mdb中去 * 接着调用这个mdb的prepareMethodOverides() 方法去校验init-method方法是否存在。不存在或者有多个则直接抛出异常 * 接下来是调用resolveBeforeInstantiation这个方法是给实现了 BeanPostProcessors接口来处理对象一个入库， 如果被BeanPostProcessors包装后生成来对象实例则直接返回生成对象 * 如果没有返回就开始进入真正的doCreateBean方法去创建对象了 现在开始进行正在的bean创建了，如果这个要创建的bean是单例模式的，先从factoryBeanInstanceCache中去取一个未完成的beanFactory的实例 + 如果factoryBeanInstanceCache为空则去创建这个实例用createBeanInstance方法 + createBeanInstance还是去前面用到的resolveBeanClass方法中去解析得到一个bean + 生成后去校验这个bean是否有公共的无参构造函数没有的话就抛出异常 + 去mdb中获取getInstanceSupplier如果有的话就使用obtainFromSupplier方法去获得一个包装类BeanWrapperImpl + 去mdb中获取getFactoryMethodName如果不为空的话用instantiateUsingFactoryMethod方法去通过静态工厂方法去获取bean获取一个BeanWrapperImpl # 具体是使用ConstructorResolver的instantiateUsingFactoryMethod方法去生成一个BeanWrapper实例的 + 如果已经解析过则使用解析好的构造函数方法不需要再次锁定 ， 一个类中有多个构造函数，判断使用哪个构造函数实例化过程比较耗性能， 所以采用缓存机制，如果已经解析过则不需要 # 重复解析而是直接从RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod缓存的值去取，否则需要 # 再次解析，并将解析的结果添加至RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod中。 + 获得BeanWrapper实例以后从BeanWrapper获取对象bean和beanType + 然后去合并所有beanDefinition的post-processors，然后在mbd.postProcessed = true; + 接着如果是单利模式并且允许提前曝光，则去获得早加载产生的bean去加载的到singletonfactory中去 + 使用populateBean方法去填充mdb但是没有看到里面有实现方法 + 使用initializeBean方法初始化bean # 初始化第一步调用invokeAwareMethods方法把bean实现的aware接口进行填充，告诉这个bean在容器中的名字 # 然后调用applyBeanPostProcessorsBeforeInitialization获取这个bean的后置处理方法后返回wrappedBean # 接着调用invokeInitMethods，如果bean的配置文件中通过init-method属性指定初始化方法，则就用这个方法去初始化bean， 真正调用是通过invokeCustomInitMethod这个方法来实现的 # 最后是调用applyBeanPostProcessorsAfterInitialization后置处理方法在bean初始化后处理的方法 + 接着判断如果当前的bean是正在创建的bean则去缓存总获取当前的bean实例， + 如果获取的bean不为空则替换前面生成的bean实例 + 否则的话检测依赖的bean是否已经全部创建，如果有没有创建完成的则直接报错 + 如果顺利就使用registerDisposableBeanIfNecessary方法去注册刚生成的bean后返回生成bean实例 * 这次返回的bean就是最后生成的bean","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://a337928.github.io/tags/spring/"}]},{"title":"设计模式六大原则(转)","date":"2017-12-21T14:48:51.000Z","path":"2017/12/21/设计模式六大原则/","text":"1、单一职责原则（Single Responsibility Principle，简称SRP ） 核心思想：应该有且仅有一个原因引起类的变更 问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。 ** 好处：**类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。 需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。 2、里氏替换原则（Liskov Substitution Principle,简称LSP） 核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。 通俗来讲：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。 好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。 需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。 3、依赖倒置原则（Dependence Inversion Principle,简称DIP） 核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象； 说明：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。 通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。 问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。 好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。 4、接口隔离原则（Interface Segregation Principle,简称ISP） 核心思想：类间的依赖关系应该建立在最小的接口上 通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 需注意：接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 5、迪米特法则（Law of Demeter,简称LoD） 核心思想：类间解耦。 通俗来讲： 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。 6、开放封闭原则（Open Close Principle,简称OCP）** 核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化 通俗来讲： 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。 一句话概括:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://a337928.github.io/tags/DesignPatterns/"}]},{"title":"redis持久化","date":"2017-11-26T14:36:36.000Z","path":"2017/11/26/redis持久化/","text":"redis简介redis是一个基于内存的nosql数据库，和传统关系数据最大的区别就是数据是存在内存中而不是硬盘上，从而带来了tps的巨大提升。但是基于内存的数据库最大的缺陷就是机器断电或者系统崩溃后数据会全部丢失。但是redis可以有一套自己的持久化机制，可以让他在系统断电或者崩溃后尽可能的少丢数据。下面就来总结下redis提供的持久化机制的各个特性。redis提供的持久化选项redis一共提供两种不同的持久化方法。一种是快照(snapshotting) 它可以将存于某一时刻的数据都写入硬盘里面。还有一种是只追加文件(append-only file AOF),它会在执行命令时，将被执行的写入命令复制到硬盘里面。这两种方法既可以单独使用也可以同时使用。快照持久化快照持久化通过写入dbfilename选项指定的文件里面，并储存在dir选项指定的路径上面。如果在新的快照文件创建完成之前，redis，系统或者硬件这三者之中的任意一个崩溃来，那么redis将丢失最近一次创建快照完成之后的所以写入数据创建快照方法1.通过客户端发送bgsave命令来创建一个快照，redis会创建一个子进程来负责写入这个快照，父进程继续处理命令请求 2.通过客户端发送save命令来创建一个快照，redis接到save命令在快照创建完成之前不再响应任何命令 3.用户配置了save配置选项，如save 60 10000 ，那么从redis最近一次创建快照开始之后，当“60秒内10000次写入”这个条件被满足时会自动触发bgsave命令。如果有多个save配置满足任意一个就会触发bgsave。 4.redis通过shutdown命令接受到关闭服务器请求时，或者收到标准的term命令时会执行save命令，阻塞所有客户端，不再执行客户端发送的命令，知道save命令执行完毕后直接关闭redis服务器。 5.当一台redis服务器连接到另一台redis服务器，并向对方发送sync命令来开始复制操作的时候，如果主服务器目前没有在执行bgsave操作，或者主服务器并非刚刚执行完bgsave操作，那么主服务器会执行bgsave命令。AOF持久化AOF持久化就是将被执行的写命令写到AOF文件的末尾，以此来记录数据发送的变化。因此redis只要从头到尾执行一次AOF文件包含的所有写命令，就可以护肤AOF文件所记录的数据。AOF持久化的创建方法通过配置 appendonly yes 来打开，通过appendsync来配置AOF文件的同步频率。 appendsync同步频率有下面这些 always 每个redis写命令都同步写入硬盘。（严重影响性能） everysec 每秒执行一次同步，显示地将多个写命令同步到硬盘 no 让操作系统来决定应该何时同步。","tags":[{"name":"redis","slug":"redis","permalink":"http://a337928.github.io/tags/redis/"},{"name":"nosql","slug":"nosql","permalink":"http://a337928.github.io/tags/nosql/"}]},{"title":"java io 学习代码","date":"2017-10-21T13:56:00.000Z","path":"2017/10/21/java代码测试/","text":"java io 练习很简单的java io 代码，启动一个服务开始等待客户端连接。收到一个客户端后连接后把和客户端的会化保存到一个Thread里面，然后一直保持这个会化接受客户端的发送的信息。 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.arthur.web.io;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.Reader;import java.net.ServerSocket;import java.net.Socket;import java.util.HashMap;import java.util.Map;import java.util.concurrent.RunnableFuture;public class ServerAi extends Thread&#123; public ServerAi(String name)&#123; super(name); &#125; private Map&lt;Integer, Runnable&gt; clients &#x3D; new HashMap&lt;&gt;(); public void run()&#123; try &#123; ServerSocket server &#x3D; new ServerSocket(5500); while (!Thread.currentThread().isInterrupted())&#123; Socket socket &#x3D; server.accept(); System.out.println(&quot;socket host : &quot; + socket.getLocalAddress() + &quot;&amp; port :&quot; + socket.getPort() ); Thread subThread &#x3D; new Thread() &#123; private Socket socketClient &#x3D; socket; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted())&#123; try &#123; Reader reader &#x3D; new BufferedReader( new InputStreamReader(socketClient.getInputStream())); for(int data &#x3D; reader.read(); data !&#x3D; -1; data &#x3D; reader.read())&#123; System.out.println((char)data); &#125; reader.close(); socketClient.close(); System.out.println(&quot;socket is closed&quot;); return; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; subThread.start(); clients.put(socket.getPort(), subThread); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.arthur.web.io;import java.io.BufferedWriter;import java.io.IOException;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import java.net.Socket;import java.util.ArrayList;import java.util.List;public class Application &#123; private static List&lt;Thread&gt; sockets &#x3D; new ArrayList&lt;&gt;(10); public static void main(String[] args) &#123; try &#123; for(int i &#x3D; 0; i &lt; 2; i ++)&#123; Thread subThread &#x3D; new Thread()&#123; private Socket socket &#x3D; new Socket(&quot;127.0.0.1&quot;,5500); public void run()&#123; OutputStream outputStream &#x3D; null; Integer i &#x3D; 0; try &#123; outputStream &#x3D; socket.getOutputStream(); Writer out &#x3D; new BufferedWriter(new OutputStreamWriter(outputStream)); while (true)&#123; if(i &gt; 10)&#123; out.close(); socket.close(); return; &#125; i++ ; out.write(&quot;测试&quot; ); out.flush(); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; subThread.start(); sockets.add(subThread); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"io","slug":"io","permalink":"http://a337928.github.io/tags/io/"}]},{"title":"设计模式 OO原则","date":"2017-10-15T15:03:48.000Z","path":"2017/10/15/设计模式-OO原则/","text":"OO原则封装变化多用组合，少用接口针对接口编程，不针对实现编程为交互对象之间的送耦合设计而努力类应该的扩张开放，对修改关闭依赖抽象，不要依赖具体类只和朋友交谈别找我，我会找你类应该只有一个改变的理由","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://a337928.github.io/tags/DesignPatterns/"}]},{"title":"jvm 运行时数据区域（读书笔记）","date":"2017-09-17T12:04:42.000Z","path":"2017/09/17/jvm/","text":"最近在看《深入理解java虚拟机》这本是书算是国内写的比较好的讲述jvm原理的是书籍，看完后自己做下读书笔记增加印象。java虚拟机运行是区域主要分为五个 程序计数器 虚拟机栈 本地方法栈 堆 方法区 1.程序计数器程序计数器是一块比较小的内存空间。可以看作是当前现场所执行的字节码的行号指示器。每条线程都有一个独立的程序计数器，在各线程之间是独立存储的，这类内存区域为“线程私有”内存。 如果是一个Native方法这个计数器值为空（Undefined）。2.java虚拟机栈虚拟机栈也是线程私有的，它的生命周期和线程相同。每个java方法在执行的时候都会创建一个栈帧。用于储存局部变量表，操作数栈，动态链接，方法出口信息等。 局部变量表存放了编译期可预知的各种基本数据类型，对象引用，returnAddress类型。 局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部空间是完全确定的，在方法运行期间不会改变局部变量的大小。3.本地方法栈本地方法栈和虚拟机栈功能基本相同，只是针对的对象不同。它针对的是虚拟机使用到的Native方法服务。在虚拟机规范中对它没有强制规定，可以把它合并到虚拟机栈中。4.堆堆是java虚拟机所管理的最大的一块内存区域。java堆是本所有的线程共享的一块内存区域，在虚拟机启动时创建。这块内存区域唯一目的就是存放对象实例，几乎所有的对象实例都创建在这里。 java堆是垃圾收集器的主要管理区域，从垃圾收集器基本采用分代收集算法来区分堆区域，堆区域还可以细分为：新生代和老年代；再细致一点有分Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）5.方法区方法区也是各个线程共享的区域，它用于储存已经被虚拟机加载的类的信息、常量、静态变量、即时编译器编译后的代码数据等。 很多人也把这个区域叫永久代。6.运行时常量运行时常量池是方法区的一部分。clas文件中除了有类似的版本、字段、方法、接口等信息描述外，还有一项信息是常量池，用于存放编译期产生的各种字面量和符号引用，这部分在类加载后进入方法区的运行时常量池中存放，还会把翻译出来的直接引用也存储在运行时常量池中。7.直接内存直接内存不是虚拟机运行时数据的一部分，也不在java虚拟机规范中定义的内存区域。在JDK1.4中加入了NIO类，引入了基于通道与缓冲区的I／O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java中的DirectByteBuffer对象作为这块内容的引用操作。","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"ivm","slug":"ivm","permalink":"http://a337928.github.io/tags/ivm/"}]},{"title":"spring－容器工厂实例化流程(一)","date":"2017-09-03T06:24:39.000Z","path":"2017/09/03/spring－容器工厂实例化流程/","text":"1.Sourcespring 初始化最先获得熟悉资源如url，url,file，2.beanDefinition通过解析source文件获得BeanDefinition,其中根节点的对象是RootBeanDefinition。3.AbstractBeanFactory1.获得RootBeanDefinition后通过AbstractBeanFactory实例化文件 2.解析RootBeanDefinition的属性时，需要使用到PropertyEditor属性编辑器。 3.getBean方法 4.先通过name获得BeanName 5.然后检查singleton是否有bean实例已经生成 ● DefaultSingletonBeanRegistry 实例化singletonbean的工厂 ● 先从singletonObjects中查找是否有已经实例化的bean有则返回 ● 没有在加载则查看是否正在加载中。 ● 如果是正在加载中，则看是否已经提前曝光 ● 如果没有提前曝光，则判定是否可以提前曝光 ● 如果可以提前曝光则去获取当前beanName的factory。 ● 如果factory存在则提前曝光当前bean，然后移除这个工厂。 6.如果检查有实例返回 ● 则检查是不是factoryBean ● 如果是普通bean实例则直接返回对象 ● 如果是factoryBean, 则去查找当前eanName的RootBeanDefinition，获取synthetic属性后去创建实例 ● 如果创建的是单列 ● 先从缓存获取当前实例。 ○ 如果没有缓存则直接获取factoryBean.getObject() ○ 返回实例 7.如果没有实例返回 ● 如果是在一个循环引用中又引用到了自己，则抛出异常 ● 检查是否有parentBeanFactory，如果有而且也包含beanName的BeanDefinition 则在parentBeanFactory中获得实例 ● 如果没有parentBeanFactory,则依次判定是否是singleton,prototype,scope; ● 根据类型创建完实例以后，再检查创建的实例是否和要创建的类有区别。 ● 最后返回bean实例。","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://a337928.github.io/tags/spring/"}]},{"title":"java io 和 nio socket","date":"2017-09-02T13:16:00.000Z","path":"2017/09/02/io-socket-nio-socket/","text":"ServerSocket 是服务器端的socket服务器ServerSocket serverSocket = new ServerSocket(9000); 通过 socket = serverSocket.accept(); 获得一个socket链接InputStream 输入流通过 inputStream inputStream = socket.getInputStream(); 获得一个输入流， 可以直接 int data = inputStream.read(); while (data != -1){ Character character = (char)data; System.out.print(character); data = inputStream.read(); } 读出数据 或者放入缓存后再读出数据 Reader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));3.outputStream 输出流OutputStream outputStream = socket.getOutputStream(); Writer out = new BufferedWriter(new OutputStreamWriter(outputStream)); out.write(&quot;success&quot;); out.flush(); 代码是通过缓存后输出，或者也可以直接输出","tags":[{"name":"java","slug":"java","permalink":"http://a337928.github.io/tags/java/"},{"name":"io","slug":"io","permalink":"http://a337928.github.io/tags/io/"}]},{"title":"mysql explain 解析","date":"2017-09-02T12:56:00.000Z","path":"2017/09/02/mysql-explain-解析/","text":"explain 解析MySQL EXPLAIN命令是查询性能优化不可缺少的一部分，该文主要讲解explain命令的使用及相关参数说明。EXPLAIN Output Columns 列名 说明 id 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 select_type 显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT） table 访问引用哪个表（引用某个查询，如“derived3”） type 数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL） possible_keys 揭示哪一些索引可能有利于高效的查找 key 显示mysql决定采用哪个索引来优化查询 key_len 显示mysql在索引里使用的字节 ref 显示了之前的表在key列记录的索引中查找值所用的列或常量 rows 为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数 Extra 额外信息，如using index、filesort等 idid是用来顺序标识整个查询中SELELCT 语句的，在嵌套查询中id越大的语句越先执行。该值可能为NULL，如果这一行用来说明的是其他行的联合结果。select_type表示查询的类型 类型 说明 simple 简单子查询，不包含子查询和union primary 包含union或者子查询，最外层的部分标记为primary subquery 一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询 derived 派生表——该临时表是从子查询派生出来的，位于form中的子查询 union 位于union中第二个及其以后的子查询被标记为union，第一个就被标记为primary如果是union位于from中则标记为derived union result 用来从匿名临时表里检索结果的select被标记为union result dependent union 顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询 subquery 子查询中第一个SELECT语句 dependent subquery 和DEPENDENT UNION相对UNION一样 table对应行正在访问哪一个表，表名或者别名 ● 关联优化器会为查询选择关联顺序，左侧深度优先 ● 当from中有子查询的时候，表名是derivedN的形式，N指向子查询，也就是explain结果中的下一列 ● 当有union result的时候，表名是union 1,2等的形式，1,2表示参与union的query id 注意：MySQL对待这些表和普通表一样，但是这些“临时表”是没有任何索引的。typetype显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。 类型 说明 All 最坏的情况,全表扫描 index 和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多 range 范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用=、 &lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range ref 一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用=或&lt;=&gt;操作符的带索引的列。 eq_ref 最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效） const 当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效） system 这是const连接类型的一种特例，表仅有一行满足条件。 Null 意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效） possible_keys显示查询使用了哪些索引，表示该索引可以进行高效地查找，但是列出来的索引对于后续优化过程可能是没有用的keykey列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。key_lenkey_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好 。refref列显示使用哪个列或常数与key一起从表中选择行。rowsrows列显示MySQL认为它执行查询时必须检查的行数。注意这是一个预估值。ExtraExtra是EXPLAIN输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息，MySQL查询优化器执行查询的过程中对查询计划的重要补充信息。 类型 说明 Using filesort MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了后者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是ordery by，group by语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。 Using temporary 用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。 Not exists MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了。 Using index 说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现using where，表明索引被用来执行索引键值的查找，没有using where，表明索引用来读取数据而非执行查找动作。这是MySQL服务层完成的，但无需再回表查询记录。 Using index condition 这是MySQL 5.6出来的新特性，叫做“索引条件推送”。简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。 Using where 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：Extra列出现Using where表示MySQL服务器将存储引擎返回服务层以后再应用WHERE条件过滤。 Using join buffer 使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接 impossible where where 子句的值总是false，不能用来获取任何元组 select tables optimized away 在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 distinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作","tags":[{"name":"mysql","slug":"mysql","permalink":"http://a337928.github.io/tags/mysql/"}]}]